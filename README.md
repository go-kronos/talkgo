# talkgo
TalkGo读书会笔记（TalkGo 读书会第一期：Linux 性能优化实战 by 倪朋飞）

《[项目文档——石墨文档](https://shimo.im/sheets/1lq7MgXnBphdeWAe/MODOC)》

[TalkGo 读书会第一期](https://talkgo.org/t/topic/136)

[Linux性能优化实战——极客专栏](https://time.geekbang.org/column/intro/140)

[启动会slide](https://docs.google.com/presentation/d/16cNCT1aqSsuVA-TPep81NGFlYIM2AO9LPFoZgA1776Y/edit?usp=sharing)

## 目标
### 笔记模式
1. 关键概念
2. 应用实战
3. 问题延伸
4. （其他记录）
### 阶段小结：
0. **每阶段产出一篇不小于200字的总结**
1. 每两周，一句话描述你在本阶段的感受（必须）
2. 最困惑的一个问题（非强制）
3. 分享自己的学习心得（非强制）

### 日常话题（作为专栏学习的讨论）：
1. 总结本专栏的有价值的问题？
2. 哪些问题可以作为面试题？
3. 实践过程中有哪些问题？

### 最终总结：
1. 参加第一期读书会的所思、所想总结
2. 对TalkGo读书会想说的话

# 第0阶段课程
《[ 开篇词 | 别再让Linux性能问题成为你的绊脚石](https://time.geekbang.org/column/article/68728)》学习笔记


很惊喜，能在我快毕业还未入职的时间阶段触及到Linux性能学习小组。
开篇词中作者提到刚参加工作那会就碰到“事故”并就此一直关注linux性能问题，
对于我而言，这件事情可能还要早一些，我在公司实习阶段就遇到我们组发生了一个多年不遇的P0事故，当然我并不是直接参与者，事故的导火索是由于上线了问题代码，
导致服务器出现雪崩效应。因为对linux底层了解不深，并没有意识到问题的严重性，直到后来跟随组内同事一起参加事故复盘讨论，我才渐渐明白事情的严重性和底层性能的重要性。
恢复服务、保留现场、定位问题，这些在线上事故发生时尤其重要。**知道事情的重要性之后，就应该尽力去想如何做到这件事**。

读了一段时间《[Linux/UNIX系统编程手册](https://book.douban.com/subject/25809330/)》，
对linux操作系统，内核接口，进程内存模型，进线程调度有了更多的理解，很多原理性的东西可以在这本书上找到答案，
但在性能实战上依然缺乏一些训练和指导，学习小组或许能帮助我填补这部分的知识空缺，这也是我为什么有些惊喜的原因。

学习从来都不是什么难事，最难的部分在于如果长期得不到想要的学习回报，我是否还能长期坚持做下去。
在这里，我提前给自己打一个预防针，做这件事情，一旦开始，就做好长期坚持的准备。

>善始善终才是生活的强者。

《[01 | 如何学习Linux性能优化？](https://time.geekbang.org/column/article/69346)》

**一般的解决问题过程**：遇见问题上网查,用别人的方法多试几次就解决了。

**劣势**：相同的错误重复再犯，相同的状况重复出现。

**更好的方法**：首先理解应用程序和系统的少数几个基本原理，实战，建立起性能全局观，然后掌握一些必要的性能工具。

![linux性能工具](../talkgo/asserts/linux_perf_tools_full.png)
[图片来源](http://www.brendangregg.com/Perf/linux_perf_tools_full.png)

# 第1阶段（CPU性能）

## 《[02 | 基础篇：到底应该怎么理解“平均负载”？](https://time.geekbang.org/column/article/69618)》

### 关键概念
1. **平均负载**(uptime工具结果):单位时间内,可运行或不可中断状态的进程平均数.
与CPU使用率之间的关系,平均负载既包含了正在使用CPU的进程(这部分计算CPU使用率),
还包括等待CPU进程和等待IO的进程.因此大量等待CPU调度进程和大量等待IO进程会导致
CPU使用率不高而平均负载特别高.

### 应用实战

预先安装 stress 和 sysstat 包，如 apt install stress sysstat。

实时查看负载均衡
```
➜  ~ watch -d uptime
 16:33:07 up 57 min,  1 user,  load average: 0.89, 0.64, 0.69
```

实时查看CPU性能
```
mpstat -P ALL 5
```
实时查看进程性能
```
pidstat -u 5 1
```

**场景一:CPU密集型进程**
```
stress --cpu 1 --timeout 600
```
**场景二:I/O密集型进程**
```
stress -i 1 --timeout 600
```
**场景三:大量进程的场景**
```
stress -c 8 --timeout 600
```

### 问题延伸
1. 进程状态都有哪些?其中哪部分属于平均负载的计算范畴.
2. uptime中的0user和多个user分别代表什么含义.

### 工具使用
**stress**:系统压测工具,模拟不同系统场景

**mpstat**:多核CPU性能分析工具,查看实时的或平均的CPU性能指标.(面向CPU)

**pidstat**:实时查看进程的CPU,内存,I/O及上下文切换等性能指标.(面向进程)

## 《[03 | 基础篇：经常说的 CPU 上下文切换是什么意思？（上）](https://time.geekbang.org/column/article/69859)》

### 关键概念
**上下文切换**:CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。比如我们想同时看多本书，从看一本书换到看另一本书（不鼓励这种来回切换地看书），在切换的时候我们就需要记住这本书看到哪里了（程序计数器），之前书里面的情节内容是什么（寄存器），然后翻开下一本书，跳到对应的页面（加载内容至程序计数器），回想起上次看到的书的内容（拷贝数据至寄存器）。进程由内核管理和调度.

### 应用实战
**场景一：进程上下文切换**

1. 用户态→系统调用→内核态，因为用户和内核数据是相互隔离的，不同状态的切换就相当于读两本不一样的书，需要进行上下文切换。并且进入内核和跳出内核都需要切换，因此每次系统调用都会产生两次上下文切换。（这种切换又称**特权模式切换**）

2. 进程间的上下文切换除了像系统调用一样需要保存寄存器/程序计数器之外，还需要把该进程虚拟内存、栈的缓存刷新到实际内存中去，所以这种切换比系统调用更慢。

3. 什么时候进程不再受到CPU的宠幸
    1. 时间片用完了
    2. 程序执行时需要的内存不够了
    3. 通过sleep函数主动挂起
    4. 高优先级进程抢占

**场景二：线程上下文切换**

线程是调度的基本单位，而进程则是资源拥有的基本单位。

进程的上下文切换实际上是对应线程的上下文切换。

另外总结一点，共享的数据不必切换，私有的数据则需要上下文切换。

同一进程下的线程由于虚拟内存和全局变量资源共享，这部分其实不用切换，其他的比如线程自己的私有数据或者寄存器程序计数器这些都需要切换。

**场景三：中断上下文切换**
对同一个 CPU 来说，中断处理比进程拥有更高的优先级。

### 问题延伸

1. 对于场景三的情况和体会不是很理解，也不是很清晰，这里留一个疑问。
2. 关于时间片内能否被打断问题，以及进程调度算法问题，这里同样留一个疑问。

## 《[04 | 基础篇：经常说的 CPU 上下文切换是什么意思？（下）](https://time.geekbang.org/column/article/70077))》

### 关键概念
1. 自愿上下文切换:进程无法获取所需资源导致上下文切换，比如I/O或内存资源不足.
2. 非自愿上下文切换:进程由于时间片到期,被系统强制调度发生上下文切换.
3. 重调度中断,它表示唤醒空闲状态的CPU来调度新的任务运行,是多处理器系统中调度器用来分散任务到不同CPU的机制.

### 应用实战

利用vmstat查看总的系统上下文切换情况
```
vmstat 1 1
```
利用pidstat查看特定进程上下文切换情况
-t参数提供进程内部多线程的切换情况,这部分切换次数不会在进程切换中体现
```
pidstat -wt 5
```
利用sysbench模拟多线程调度情况
```
sysbench --threads=10 --max-time=300 threads run
```
查看调度的中断情况
```
watch -d cat /proc/interrupts
```

### 问题延伸

### 工具使用

1. vmstat 1
2. pidstat -w -t 
3. sysbench:多线程基准测试工具.
4. /proc/interrupts 提供只读的中断使用情况.

### 简单小结
总而言之,上下文切换以及系统中断的时间相当于操作系统在划水的时间,我们要通过以上手段找出来系统在什么时候划水不干正事,并期望减小这些划水的时间,让CPU尽可能多的去干正事.

完。

//模板，8yy复制
### 关键概念

### 应用实战

### 问题延伸

### 其他
