[TOC]

# CPU性能篇

## 什么是平均负载？

平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。

可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。

不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。

不可中断状态实际上是系统对进程和硬件设备的一种保护机制。

当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。

但 70% 这个数字并不是绝对的，最推荐的方法，还是把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势。当发现负载有明显升高趋势时，比如说负载翻倍了，你再去做分析和调查。

平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：平均负载高有可能是 CPU 密集型进程导致的；平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。



## 怎么理解上下文切换？

CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文。

CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是进程上下文切换、线程上下文切换以及中断上下文切换。

Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。

- 内核空间（Ring 0）具有最高权限，可以直接访问所有资源；
- 用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。

一次系统调用的过程发生了两次CPU上下文切换

- 进程上下文切换是从一个进程切换到另一个进程进行

- 系统调用过程中一直是同一个进程在运行。系统调用过程通常称为特权模式切换。

  系统调用并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。而进程的上下文切换比系统调用时多了一步：在保存当前进程的内核状态和CPU寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。

  

### 什么时候会切换进程上下文？

- 时间片
- 系统资源不足
- 睡眠函数主动挂起
- 有优先级更高的进程运行时
- 硬件中断

### 线程上下文切换

- 两个现成属于不同进程。跟进程一样
- 属于同一个进程。只需要切换线程的私有数据、寄存器等不共享的数据

### 中断上下文切换

中断处理会打断进程的正常调度和执行。并不涉及到进程的用户态。

过多的上下文切换，会把CPU时间消耗在寄存器、内核栈、以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。

>  自愿上下文切换是指进程无法获取所需资源，导致的上下文切换。比如说。IO、内存等系统资源不足时，就会发生自愿上下文切换。
>
> 非自愿上下文切换 ，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢CPU时，就容易发生非自愿上下文切换。

模拟系统多线程调度

```shell
# 以10个线程运行5分钟的基准测试，模拟多线程切换的问题
$ sysbench --threads=10 --max-time=300 threads run
```

观察上下文情况

```shell
# 每隔1秒输出1组数据（需要Ctrl+C才结束）
$ vmstat 1
```



观察CPU 和进程及线程上下文切换的情况

```shell
# 每隔1秒输出1组数据（需要 Ctrl+C 才结束）
# -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标
# -wt 参数表示输出线程的上下文切换指标
$ pidstat -w -u 1
```



### 上下文情况得具体问题具体分析：

- 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了IO等其他问题
- 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢CPU。说明CPU的确成了瓶颈。
- 中断次数变多了，说明CPU被中断处理程序占用，还需要通过查看/proc/interrupts文件来分析具体的中断类型

## 某个应用的CPU使用率打到了100%，我该什么办？

CPU使用率是单位时间内CPU使用情况的统计，以百分比的方式展示。

CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比。

![img](https://static001.geekbang.org/resource/image/3e/09/3edcc7f908c7c1ddba4bbcccc0277c09.png)

![img](https://static001.geekbang.org/resource/image/84/5a/8408bb45922afb2db09629a9a7eb1d5a.png)

### CPU使用率过高怎么办？

perf 是 Linux 2.6.31 以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。

```shell
# 查看进程占用cpu情况
top

# -g开启调用关系分析，-p指定php-fpm的进程号21515$ 
perf top -g -p 21515
```

小结：

- 用户CPU和Nice CPU高，说明用户态进程占用了较多的CPU，所以应该着重排查进程的性能问题
- 系统CPU高，说明内核态占用了较多的CPU，所以应该着重排查内核线程或者系统调用的性能问题
- IO等待CPU高，说明等待IO的时间长，所以应该着重排查系统存储是不是出现了IO问题
- 软中断和硬中断高，说明软中断或者硬中断的处理程序占用了较多的CPU，所以应该着重排查内核中的中断服务程序

碰到CPU使用率升高的问题，可以借助top、pidstat等工具，确认引发CPU性能问题的来源；再使用perf等工具，排查出引起性能问题的具体函数。



### 系统中出现大量不可中断进程和僵尸进程怎么办？

僵尸进程，这是多进程应用很容易碰到的问题。正常情况下，当一个进程创建了子进程后，它应该通过系统调用 wait() 或者 waitpid() 等待子进程结束，回收子进程的资源；而子进程在结束时，会向它的父进程发送 SIGCHLD 信号，所以，父进程还可以注册 SIGCHLD 信号的处理函数，异步回收资源。

dstat 是一个新的性能工具。可以同时观察系统的 CPU、磁盘 I/O、网络以及内存使用情况。

- 不可中断状态，表示进程正在跟硬件交互，为了保护进程数据和硬件的一致性，系统不允许其他进程或中断打断这个进程。进程长时间处于不可中断状态，通常表示系统有 I/O 性能问题。
- 僵尸进程表示进程已经退出，但它的父进程还没有回收子进程占用的资源。短暂的僵尸状态我们通常不必理会，但进程长时间处于僵尸状态，就应该注意了，可能有应用程序没有正常处理子进程的退出。

查询系统IO情况

```shell
# 间隔1秒输出10组数据$ 
dstat 1 10
```

查看某个进程的资源使用情况

```shell
# -d 展示 I/O 统计数据，-p 指定进程号，间隔 1 秒输出 3 组数
pidstat -d -p 4344 1 3
```

跟踪进程系统调用

```shell
# -p 参数指定 PID 号
strace -p 6082
```

僵尸进程怎么找到父进程

```shell
# -a 表示输出命令行选项
# p表PID
# s表示指定进程的父进程$ 
pstree -aps 3084
```

小结：

-  iowait 高不一定代表 I/O 有性能瓶颈。当系统中只有 I/O 类型的进程在运行时，iowait 也会很高，但实际上，磁盘的读写远没有达到性能瓶颈的程度。
- 碰到 iowait 升高时，需要先用 dstat、pidstat 等工具，确认是不是磁盘 I/O 的问题，然后再找是哪些进程导致了 I/O。
- 等待 I/O 的进程一般是不可中断状态，所以用 ps 命令找到的 D 状态（即不可中断状态）的进程，多为可疑进程。
- 僵尸进程的问题相对容易排查，使用 pstree 找出父进程后，去查看父进程的代码，检查 wait() / waitpid() 的调用，或是 SIGCHLD 信号处理函数的注册就行了

## 系统软中断CPU使用率升高，该怎么办？

- sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据。
- hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等。
- tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题。

模拟请求：

```shell
# -S参数表示设置TCP协议的SYN（同步序列号），-p表示目的端口为80
# -i u100表示每隔100微秒发送一个网络帧
# 注：如果你在实践过程中现象不明显，可以尝试把100调小，比如调成10甚至1
$ hping3 -S -p 80 -i u100 192.168.0.30
```

观察软中断文件内容变化

```shell
watch -d cat /proc/softirqs
```

sar 可以用来查看系统的网络收发情况，还有一个好处是，不仅可以观察网络收发的吞吐量（BPS，每秒收发的字节数），还可以观察网络收发的 PPS，即每秒收发的网络帧数。我们在第一个终端中运行 sar 命令，并添加 -n DEV 参数显示网络收发的报告：

```	
# -n DEV 表示显示网络收发的报告，间隔1秒输出一组数据
$ sar -n DEV 1
```

我们在第一个终端中运行 tcpdump 命令，通过 -i eth0 选项指定网卡 eth0，并通过 tcp port 80 选项指定 TCP 协议的 80 端口：

```shell
# -i eth0 只抓取eth0网卡，-n不解析协议名和主机名
# tcp port 80表示只抓取tcp协议并且端口号为80的网络帧
$ tcpdump -i eth0 -n tcp port 80
```

SYN FLOOD 问题最简单的解决方法，就是从交换机或者硬件防火墙中封掉来源 IP，这样 SYN FLOOD 网络帧就不会发送到服务器中。

小结：

软中断 CPU 使用率（softirq）升高是一种很常见的性能问题。虽然软中断的类型很多，但实际生产中，我们遇到的性能瓶颈大多是网络收发类型的软中断，特别是网络接收的软中断。

## 如何快速的分析出系统CPU瓶颈在哪里？

### CPU 性能指标

#### CPU 使用率

CPU 使用率描述了非空闲时间占总 CPU 时间的百分比，根据 CPU 上运行任务的不同，又被分为用户 CPU、系统 CPU、等待 I/O CPU、软中断和硬中断等。

1. 用户 CPU 使用率，包括用户态 CPU 使用率（user）和低优先级用户态 CPU 使用率（nice），表示 CPU 在用户态运行的时间百分比。用户 CPU 使用率高，通常说明有应用程序比较繁忙。
2. 系统 CPU 使用率，表示 CPU 在内核态运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明内核比较繁忙。
3. 等待 I/O 的 CPU 使用率，通常也称为 iowait，表示等待 I/O 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互时间比较长。
4. 软中断和硬中断的 CPU 使用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断。
5. 在虚拟化环境中会用到的窃取 CPU 使用率（steal）和客户 CPU 使用率（guest），分别表示被其他虚拟机占用的 CPU 时间百分比，和运行客户虚拟机的 CPU 时间百分比。

#### 平均负载（Load Average）

也就是系统的平均活跃进程数。它反应了系统的整体负载情况，主要包括三个数值，分别指过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。

### 进程上下文切换

1. 无法获取资源而导致的自愿上下文切换
2. 被系统强制调度导致的非自愿上下文切换

过多的上下文切换，会将原本运行进程的 CPU 时间，消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，成为性能瓶颈。

### CPU 缓存的命中率

![img](https://static001.geekbang.org/resource/image/aa/33/aa08816b60e453b52b5fae5e63549e33.png)

### CUP性能指标

![img](https://static001.geekbang.org/resource/image/1e/07/1e66612e0022cd6c17847f3ab6989007.png)

### 性能工具

#### 平均负载的案例

1. 先用 uptime， 查看了系统的平均负载
2. 用 mpstat 和 pidstat ，分别观察了每个 CPU 和每个进程 CPU 的使用情况，进而找出了导致平均负载升高的进程

#### 上下文切换的案例

1. 先用 vmstat ，查看了系统的上下文切换次数和中断次数
2. 通过 pidstat ，观察了进程的自愿上下文切换和非自愿上下文切换情况
3. 通过 pidstat ，观察了线程的上下文切换情况，找出了上下文切换次数增多的根源

#### 进程 CPU 使用率升高的案例

1. 先用 top ，查看了系统和进程的 CPU 使用情况
2. 发现 CPU 使用率升高的进程是 php-fpm；再用 perf top ，观察 php-fpm 的调用链，最终找出 CPU 升高的根源

#### 系统的 CPU 使用率升高的案例

1. 用 top 观察到了系统 CPU 升高，但通过 top 和 pidstat ，却找不出高 CPU 使用率的进程
2. 重新审视 top 的输出，又从 CPU 使用率不高但处于 Running 状态的进程入手，找出了可疑之处
3. 最终通过 perf record 和 perf report ，发现原来是短时进程在捣鬼。
4. 对于短时进程，有一个专门的工具 execsnoop，它可以实时监控进程调用的外部命令。

#### 不可中断进程和僵尸进程的案例

1. 先用 top 观察到了 iowait 升高的问题，并发现了大量的不可中断进程和僵尸进程
2. 用 dstat 发现是这是由磁盘读导致的，于是又通过 pidstat 找出了相关的进程
3. 但用 strace 查看进程系统调用却失败了，最终还是用 perf 分析进程调用链，才发现根源在于磁盘直接 I/O 。

#### 软中断的案例

1. 通过 top 观察到，系统的软中断 CPU 使用率升高
2. 接着查看 /proc/softirqs， 找到了几种变化速率较快的软中断
3. 通过 sar 命令，发现是网络小包的问题
4. 最后再用 tcpdump ，找出网络帧的类型和来源，确定是一个 SYN FLOOD 攻击导致的

### 活学活用，把性能指标和性能工具联系起来

第一个维度，从 CPU 的性能指标出发。也就是说，当你要查看某个性能指标时，要清楚知道哪些工具可以做到。

![img](https://static001.geekbang.org/resource/image/59/ec/596397e1d6335d2990f70427ad4b14ec.png)

第二个维度，从工具出发。也就是当你已经安装了某个工具后，要知道这个工具能提供哪些指标。

![img](https://static001.geekbang.org/resource/image/b0/ca/b0c67a7196f5ca4cc58f14f959a364ca.png)

### 如何迅速分析 CPU 的性能瓶颈

想弄清楚性能指标的关联性，就要通晓每种性能指标的工作原理。

为了缩小排查范围，我通常会先运行几个支持指标较多的工具，如 top、vmstat 和 pidstat。

![img](https://static001.geekbang.org/resource/image/7a/17/7a445960a4bc0a58a02e1bc75648aa17.png)

这三个命令，几乎包含了所有重要的 CPU 性能指标：

- 从 top 的输出可以得到各种 CPU 使用率以及僵尸进程和平均负载等信息。
- 从 vmstat 的输出可以得到上下文切换次数、中断次数、运行状态和不可中断状态的进程数。
- 从 pidstat 的输出可以得到进程的用户 CPU 使用率、系统 CPU 使用率、以及自愿上下文切换和非自愿上下文切换情况。

# CPU 性能优化的几个思路

<<<<<<< HEAD:Markdown文档学习记录/Linux性能优化实践/CPU性能篇.md
### 性能优化方法论

考虑的点：

首先，既然要做性能优化，那要怎么判断它是不是有效呢？特别是优化后，到底能提升多少性能呢？

第二，性能问题通常不是独立的，如果有多个性能问题同时发生，你应该先优化哪一个呢？

第三，提升性能的方法并不是唯一的，当有多种方法可以选择时，你会选用哪一种呢？是不是总选那个最大程度提升性能的方法就行了呢？

### 怎么评估性能优化的效果？

为了评估这个效果，我们需要对系统的性能指标进行量化，并且要分别测试出优化前、后的性能指标，用前后指标的变化来对比呈现效果。我把这个方法叫做性能评估“三步走”。

1. 确定性能的量化指标
2. 测试优化前的性能指标
3. 测试优化后的性能指标

性能的量化指标有很多，比如 CPU 使用率、应用程序的吞吐量、客户端请求的延迟等，都可以评估性能。

- 应用程序的维度，我们可以用吞吐量和请求延迟来评估应用程序的性能
- 系统资源的维度，我们可以用 CPU 使用率来评估系统的 CPU 使用情况

- 好的应用程序是性能优化的最终目的和结果，系统优化总是为应用程序服务的。所以，必须要使用应用程序的指标，来评估性能优化的整体效果
- 系统资源的使用情况是影响应用程序性能的根源。所以，需要用系统资源的指标，来观察和分析瓶颈的来源

在进行性能测试时，有两个特别重要的地方你需要注意下:

第一，要避免性能测试工具干扰应用程序的性能。通常，对 Web 应用来说，性能测试工具跟目标应用程序要在不同的机器上运行。

第二，避免外部环境的变化影响性能指标的评估。这要求优化前、后的应用程序，都运行在相同配置的机器上，并且它们的外部依赖也要完全一致。

### 多个性能问题同时存在，要怎么选择？

在性能测试的领域，流传很广的一个说法是“二八原则”，也就是说 80% 的问题都是由 20% 的代码导致的。只要找出这 20% 的位置，你就可以优化 80% 的性能。所以，我想表达的是，并不是所有的性能问题都值得优化。

动手优化之前先动脑，先把所有这些性能问题给分析一遍，找出最重要的、可以最大程度提升性能的问题，从它开始优化。这样的好处是，不仅性能提升的收益最大，而且很可能其他问题都不用优化，就已经满足了性能要求。

第一，如果发现是系统资源达到了瓶颈，比如 CPU 使用率达到了 100%，那么首先优化的一定是系统资源使用问题。完成系统资源瓶颈的优化后，我们才要考虑其他问题。

第二，针对不同类型的指标，首先去优化那些由瓶颈导致的，性能指标变化幅度最大的问题。比如产生瓶颈后，用户 CPU 使用率升高了 10%，而系统 CPU 使用率却升高了 50%，这个时候就应该首先优化系统 CPU 的使用。

### 有多种优化方法时，要如何选择?

性能优化并非没有成本。性能优化通常会带来复杂度的提升，降低程序的可维护性，还可能在优化一个指标时，引发其他指标的异常。

### CPU 优化

#### 应用程序优化

降低 CPU 使用率的最好方法当然是，排除所有不必要的工作，只保留最核心的逻辑。比如减少循环的层次、减少递归、减少动态内存分配等等

- 编译器优化
  - 
- 算法优化
  - 比如，在数据比较大的情况下，可以用 O(nlogn) 的排序算法（如快排、归并排序等），代替 O(n^2) 的排序算法（如冒泡、插入排序等）。
- 异步处理
  - 把轮询替换为事件通知，就可以避免轮询耗费 CPU 的问题
- 多线程代替多进程
- 善用缓存
  - 经常访问的数据或者计算过程中的步骤，可以放到内存中缓存起来，这样在下次用时就能直接从内存中获取，加快程序的处理速度。

#### 系统优化

从系统的角度来说，优化 CPU 的运行，一方面要充分利用 CPU 缓存的本地性，加速缓存访问；另一方面，就是要控制进程的 CPU 使用情况，减少进程间的相互影响。

- CPU 绑定：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题。
- CPU 独占：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU。
- 优先级调整：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级
- 为进程设置资源限制：使用 Linux cgroups 来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源。
- NUMA（Non-Uniform Memory Access）优化：支持 NUMA 的处理器会被划分为多个 node，每个 node 都有自己的本地内存空间。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存
- 中断负载均衡：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把中断处理过程自动负载均衡到多个 CPU 上。

### 千万避免过早优化

# 

